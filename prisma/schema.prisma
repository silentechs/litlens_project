// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============== AUTHENTICATION ==============

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?   // For credentials auth

  // Profile
  bio           String?
  orcid         String?   @unique
  institution   String?
  role          UserRole  @default(USER)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts              Account[]
  sessions              Session[]
  organizationMembers   OrganizationMember[]
  projectMembers        ProjectMember[]
  screeningDecisions    ScreeningDecision[]
  conflictResolutions   ConflictResolution[]
  libraryItems          LibraryItem[]
  libraryFolders        LibraryFolder[]
  researchAlerts        ResearchAlert[]
  researchGraphs        ResearchGraph[]
  writingProjects       WritingProject[]
  activities            Activity[]
  notifications         Notification[]
  preferences           UserPreferences?
  extractionData        ExtractionData[]
  qualityAssessments    QualityAssessment[]
  chatMessages          ChatMessage[]
  sentInvitations       ProjectInvitation[]

  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model UserPreferences {
  id                   String   @id @default(cuid())
  userId               String   @unique
  
  // Notification settings
  emailNotifications   Boolean  @default(true)
  pushNotifications    Boolean  @default(false)
  inAppNotifications   Boolean  @default(true)
  
  // Quiet hours
  quietHoursEnabled    Boolean  @default(false)
  quietHoursStart      String?  // "22:00"
  quietHoursEnd        String?  // "08:00"
  quietHoursDays       String[] @default([])
  
  // Alert digest
  alertDigestFrequency String   @default("daily") // immediate, daily, weekly
  
  // UI preferences
  theme                String   @default("system")
  sidebarCollapsed     Boolean  @default(false)
  
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

// ============== ORGANIZATION ==============

model Organization {
  id              String   @id @default(cuid())
  name            String
  slug            String   @unique
  domain          String?  @unique
  logoUrl         String?
  primaryColor    String   @default("#4F46E5")

  // Billing
  tier                   OrganizationTier @default(FREE)
  maxProjects            Int              @default(3)
  maxMembers             Int              @default(5)
  maxStudiesPerProject   Int              @default(500)
  stripeCustomerId       String?          @unique
  stripeSubscriptionId   String?
  currentPeriodEnd       DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  members         OrganizationMember[]
  projects        Project[]
  apiKeys         ApiKey[]
  auditLogs       AuditLog[]
  invitations     OrganizationInvitation[]
  webhooks        Webhook[]

  @@index([slug])
}

enum OrganizationTier {
  FREE
  PROFESSIONAL
  TEAM
  ENTERPRISE
}

model OrganizationMember {
  id             String           @id @default(cuid())
  organizationId String
  userId         String
  role           OrganizationRole @default(MEMBER)
  capabilities   Json             @default("[]")
  joinedAt       DateTime         @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([organizationId])
  @@index([userId])
}

enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
  GUEST
}

model OrganizationInvitation {
  id             String   @id @default(cuid())
  organizationId String
  email          String
  role           OrganizationRole @default(MEMBER)
  token          String   @unique
  expiresAt      DateTime
  acceptedAt     DateTime?
  createdAt      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([email])
}

// ============== PROJECTS ==============

model Project {
  id              String   @id @default(cuid())
  organizationId  String?
  
  // Basic info
  title           String
  description     String?  @db.Text
  slug            String   @unique
  status          ProjectStatus @default(ACTIVE)
  
  // PICO Framework
  population      String?  @db.Text
  intervention    String?  @db.Text
  comparison      String?  @db.Text
  outcome         String?  @db.Text
  
  // Settings
  isPublic        Boolean  @default(false)
  blindScreening  Boolean  @default(true)
  requireDualScreening Boolean @default(true)
  highlightKeywords String[] @default([])
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  archivedAt      DateTime?

  organization    Organization? @relation(fields: [organizationId], references: [id])
  
  // Relations
  members         ProjectMember[]
  projectWorks    ProjectWork[]
  importBatches   ImportBatch[]
  screeningDecisions ScreeningDecision[]
  conflicts       Conflict[]
  extractionTemplates ExtractionTemplate[]
  extractionData  ExtractionData[]
  qualityTools    QualityAssessmentTool[]
  qualityAssessments QualityAssessment[]
  activities      Activity[]
  protocol        ReviewProtocol?
  livingReviewConfig LivingReviewConfig?
  researchAlerts  ResearchAlert[]
  researchGraphs  ResearchGraph[]
  writingProjects WritingProject[]
  calibrationRounds CalibrationRound[]
  chatMessages    ChatMessage[]
  invitations     ProjectInvitation[]

  @@index([organizationId])
  @@index([status])
  @@index([slug])
}

enum ProjectStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  ARCHIVED
}

model ProjectMember {
  id        String      @id @default(cuid())
  projectId String
  userId    String
  role      ProjectRole @default(REVIEWER)
  joinedAt  DateTime    @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

enum ProjectRole {
  OWNER
  LEAD
  REVIEWER
  OBSERVER
}

model ProjectInvitation {
  id        String   @id @default(cuid())
  projectId String
  email     String
  role      ProjectRole @default(REVIEWER)
  token     String   @unique
  expiresAt DateTime
  
  invitedBy String
  inviter   User     @relation(fields: [invitedBy], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, email])
  @@index([token])
  @@index([email])
}

// ============== CANONICAL WORK ENTITY ==============

model Work {
  id                String   @id @default(cuid())
  
  // Universal identifiers
  doi               String?  @unique
  pmid              String?  @unique
  pmcid             String?
  openAlexId        String?  @unique
  semanticScholarId String?
  arxivId           String?
  
  // Core metadata
  title             String
  abstract          String?  @db.Text
  authors           Json     @default("[]")  // [{name, orcid, affiliation}]
  year              Int?
  publicationDate   DateTime?
  journal           String?
  volume            String?
  issue             String?
  pages             String?
  publisher         String?
  url               String?
  
  // Enrichment
  keywords          String[] @default([])
  meshTerms         String[] @default([])
  subjects          String[] @default([])
  references        String[] @default([])  // DOIs of cited works
  citationCount     Int      @default(0)
  
  // Tracking
  source            String   @default("import")  // import, openalex, pubmed, crossref
  enrichedAt        DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relations
  projectWorks      ProjectWork[]
  libraryItems      LibraryItem[]
  graphNodes        GraphNode[]
  writingSources    WritingSource[]

  @@index([doi])
  @@index([pmid])
  @@index([openAlexId])
  @@index([title])
}

// Work inside a systematic review project
model ProjectWork {
  id            String   @id @default(cuid())
  projectId     String
  workId        String
  
  // Import metadata
  importBatchId String?
  importSource  String?  // filename, database name
  rawRecord     Json?    // original RIS/BibTeX record
  
  // Workflow status
  status        ProjectWorkStatus @default(PENDING)
  phase         ScreeningPhase    @default(TITLE_ABSTRACT)
  finalDecision ScreeningDecision?
  
  // AI-assisted screening
  aiSuggestion  String?           // AI's recommended decision
  aiConfidence  Float?            // 0-1 confidence score
  aiReasoning   String?  @db.Text // AI's explanation
  
  // Queue optimization
  priorityScore Int      @default(50)  // 0-100 priority for screening queue
  
  // Duplicate tracking
  isDuplicate   Boolean  @default(false)
  duplicateOfId String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  project       Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  work          Work         @relation(fields: [workId], references: [id], onDelete: Cascade)
  importBatch   ImportBatch? @relation(fields: [importBatchId], references: [id])
  duplicateOf   ProjectWork? @relation("DuplicateRelation", fields: [duplicateOfId], references: [id])
  duplicates    ProjectWork[] @relation("DuplicateRelation")
  
  decisions          ScreeningDecisionRecord[]
  extractionData     ExtractionData[]
  qualityAssessments QualityAssessment[]
  conflicts          Conflict[]

  @@unique([projectId, workId])
  @@index([projectId, status])
  @@index([projectId, phase])
  @@index([importBatchId])
  @@index([aiConfidence])
  @@index([priorityScore])
}

enum ProjectWorkStatus {
  PENDING
  SCREENING
  CONFLICT
  INCLUDED
  EXCLUDED
  MAYBE
}

enum ScreeningPhase {
  TITLE_ABSTRACT
  FULL_TEXT
  FINAL
}

enum ScreeningDecision {
  INCLUDE
  EXCLUDE
  MAYBE
}

// ============== IMPORT ==============

model ImportBatch {
  id          String   @id @default(cuid())
  projectId   String
  
  filename    String
  fileSize    Int
  fileType    String   // ris, bibtex, csv, endnote
  
  status      ImportStatus @default(PENDING)
  totalRecords Int      @default(0)
  processedRecords Int  @default(0)
  duplicatesFound Int   @default(0)
  errorsCount Int       @default(0)
  
  errorLog    Json?
  
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime @default(now())
  
  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectWorks ProjectWork[]

  @@index([projectId])
  @@index([status])
}

enum ImportStatus {
  PENDING
  UPLOADING
  PARSING
  ENRICHING
  DEDUPLICATING
  COMPLETED
  FAILED
}

// ============== SCREENING ==============

model ScreeningDecisionRecord {
  id            String   @id @default(cuid())
  projectWorkId String
  reviewerId    String
  
  phase         ScreeningPhase
  decision      ScreeningDecision
  reasoning     String?  @db.Text
  exclusionReason String?
  confidence    Int?     // User's confidence score (0-100)

  // AI assistance
  aiSuggestion      ScreeningDecision?
  aiConfidence      Float?
  aiReasoning       String?  @db.Text
  followedAi        Boolean?
  
  // Timing
  timeSpentMs   Int?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  projectWork   ProjectWork @relation(fields: [projectWorkId], references: [id], onDelete: Cascade)

  @@unique([projectWorkId, reviewerId, phase])
  @@index([projectWorkId])
  @@index([reviewerId])
}

model Conflict {
  id            String   @id @default(cuid())
  projectId     String
  projectWorkId String
  phase         ScreeningPhase
  
  status        ConflictStatus @default(PENDING)
  
  // The differing decisions
  decisions     Json     // Array of {reviewerId, decision, reasoning}
  
  // Escalation tracking
  escalatedAt      DateTime?
  escalatedBy      String?
  escalationReason String?  @db.Text
  
  createdAt     DateTime @default(now())
  resolvedAt    DateTime?
  
  project       Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectWork   ProjectWork @relation(fields: [projectWorkId], references: [id], onDelete: Cascade)
  resolution    ConflictResolution?

  @@index([projectId, status])
  @@index([projectWorkId])
}

enum ConflictStatus {
  PENDING
  IN_DISCUSSION
  RESOLVED
}

model ConflictResolution {
  id            String   @id @default(cuid())
  conflictId    String   @unique
  resolverId    String
  
  finalDecision ScreeningDecision
  reasoning     String?  @db.Text
  
  createdAt     DateTime @default(now())
  
  conflict      Conflict @relation(fields: [conflictId], references: [id], onDelete: Cascade)
  resolver      User     @relation(fields: [resolverId], references: [id])
}

// ============== CALIBRATION ==============

model CalibrationRound {
  id              String   @id @default(cuid())
  projectId       String
  phase           ScreeningPhase
  
  sampleSize      Int      @default(20)
  targetAgreement Float    @default(0.8)  // Kappa threshold
  
  status          CalibrationStatus @default(PENDING)
  kappaScore      Float?
  percentAgreement Float?
  
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime @default(now())
  
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  decisions       CalibrationDecision[]

  @@index([projectId])
}

model CalibrationDecision {
  id            String   @id @default(cuid())
  roundId       String
  projectWorkId String
  reviewerId    String
  
  decision      ScreeningDecision
  reasoning     String?
  timeSpentMs   Int?
  
  createdAt     DateTime @default(now())
  
  round         CalibrationRound @relation(fields: [roundId], references: [id], onDelete: Cascade)

  @@index([roundId])
}

enum CalibrationStatus {
  PENDING
  IN_PROGRESS
  PASSED
  FAILED
  NEEDS_DISCUSSION
}

// ============== EXTRACTION ==============

model ExtractionTemplate {
  id            String   @id @default(cuid())
  projectId     String
  
  name          String
  description   String?
  version       Int      @default(1)
  isActive      Boolean  @default(true)
  
  // Field definitions as JSON
  fields        Json     @default("[]")  // Array of field definitions
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  extractionData ExtractionData[]

  @@index([projectId])
}

model ExtractionData {
  id            String   @id @default(cuid())
  projectId     String
  projectWorkId String
  templateId    String
  extractorId   String
  
  // Extracted values
  data          Json     @default("{}")
  
  status        ExtractionStatus @default(IN_PROGRESS)
  
  // Validation
  isValid       Boolean  @default(true)
  validationErrors Json? // Array of validation errors
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectWork   ProjectWork @relation(fields: [projectWorkId], references: [id], onDelete: Cascade)
  template      ExtractionTemplate @relation(fields: [templateId], references: [id])
  extractor     User     @relation(fields: [extractorId], references: [id])
  discrepancies ExtractionDiscrepancy[]

  @@unique([projectWorkId, templateId, extractorId])
  @@index([projectId])
  @@index([projectWorkId])
}

enum ExtractionStatus {
  IN_PROGRESS
  COMPLETED
  NEEDS_REVIEW
  VERIFIED
}

model ExtractionDiscrepancy {
  id              String   @id @default(cuid())
  extractionId    String
  
  fieldName       String
  value1          String?
  value2          String?
  
  status          DiscrepancyStatus @default(PENDING)
  resolvedValue   String?
  resolvedBy      String?
  
  createdAt       DateTime @default(now())
  resolvedAt      DateTime?
  
  extraction      ExtractionData @relation(fields: [extractionId], references: [id], onDelete: Cascade)

  @@index([extractionId])
}

enum DiscrepancyStatus {
  PENDING
  RESOLVED
  IGNORED
}

// ============== QUALITY ASSESSMENT ==============

model QualityAssessmentTool {
  id          String   @id @default(cuid())
  projectId   String
  
  name        String   // e.g., "RoB 2.0", "GRADE", "Newcastle-Ottawa"
  type        QualityToolType
  domains     Json     @default("[]")  // Assessment domains/criteria
  
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assessments QualityAssessment[]

  @@index([projectId])
}

enum QualityToolType {
  ROB2          // Risk of Bias 2.0
  ROBINS_I      // ROBINS-I for non-randomized
  NEWCASTLE_OTTAWA
  GRADE
  CUSTOM
}

model QualityAssessment {
  id              String   @id @default(cuid())
  projectId       String
  projectWorkId   String
  toolId          String
  assessorId      String
  
  // Assessment data
  domainScores    Json     @default("{}")  // {domain: {score, justification}}
  overallScore    String?  // e.g., "High Risk", "Some Concerns", "Low Risk"
  overallJustification String? @db.Text
  
  status          AssessmentStatus @default(IN_PROGRESS)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  projectWork     ProjectWork @relation(fields: [projectWorkId], references: [id], onDelete: Cascade)
  tool            QualityAssessmentTool @relation(fields: [toolId], references: [id])
  assessor        User     @relation(fields: [assessorId], references: [id])

  @@unique([projectWorkId, toolId, assessorId])
  @@index([projectId])
  @@index([projectWorkId])
}

enum AssessmentStatus {
  IN_PROGRESS
  COMPLETED
  NEEDS_CONSENSUS
}

// ============== PROTOCOL & GOVERNANCE ==============

model ReviewProtocol {
  id              String   @id @default(cuid())
  projectId       String   @unique
  
  title           String
  version         Int      @default(1)
  content         Json     @default("{}")  // Structured PRISMA-P sections
  
  // Registration
  prosperoId      String?
  registrationDate DateTime?
  
  // Versioning
  isLocked        Boolean  @default(false)
  lockedAt        DateTime?
  lockedBy        String?
  
  status          ProtocolStatus @default(DRAFT)
  approvedAt      DateTime?
  approvedBy      String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  versions        ProtocolVersion[]
  milestones      ProtocolMilestone[]
}

enum ProtocolStatus {
  DRAFT
  PENDING_APPROVAL
  APPROVED
  REGISTERED
  AMENDED
}

model ProtocolVersion {
  id              String   @id @default(cuid())
  protocolId      String
  version         Int
  content         Json
  changeLog       String?
  createdBy       String
  createdAt       DateTime @default(now())
  
  protocol        ReviewProtocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  @@index([protocolId])
}

model ProtocolMilestone {
  id              String   @id @default(cuid())
  protocolId      String
  
  name            String
  targetDate      DateTime?
  completedAt     DateTime?
  isLocked        Boolean  @default(false)
  
  protocol        ReviewProtocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  @@index([protocolId])
}

// ============== LIVING REVIEWS ==============

model LivingReviewConfig {
  id              String   @id @default(cuid())
  projectId       String   @unique
  isEnabled       Boolean  @default(false)
  
  updateFrequency String   @default("WEEKLY")  // DAILY, WEEKLY, MONTHLY
  lastUpdateAt    DateTime?
  nextUpdateAt    DateTime?
  
  searchStrategies Json    @default("[]")
  dataSources     Json     @default("[\"openalex\", \"pubmed\"]")
  
  autoScreenEnabled Boolean @default(false)
  autoExcludeThreshold Float @default(0.95)
  
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  updateHistory   LivingReviewUpdate[]
}

model LivingReviewUpdate {
  id              String   @id @default(cuid())
  configId        String
  
  newStudiesFound Int      @default(0)
  studiesAdded    Int      @default(0)
  autoExcluded    Int      @default(0)
  
  status          String   @default("COMPLETED")
  errorMessage    String?
  
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  
  config          LivingReviewConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([configId])
}

// ============== PERSONAL LIBRARY ==============

model LibraryItem {
  id              String   @id @default(cuid())
  userId          String
  workId          String
  folderId        String?
  
  // User additions
  tags            String[] @default([])
  notes           String?  @db.Text
  rating          Int?
  readingStatus   ReadingStatus @default(TO_READ)
  highlightColor  String?
  
  // AI-generated
  aiSummary       String?  @db.Text
  aiKeyInsights   Json?
  
  lastAccessedAt  DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  work            Work          @relation(fields: [workId], references: [id], onDelete: Cascade)
  folder          LibraryFolder? @relation(fields: [folderId], references: [id])

  @@unique([userId, workId])
  @@index([userId])
  @@index([folderId])
}

enum ReadingStatus {
  TO_READ
  READING
  READ
  ARCHIVED
}

model LibraryFolder {
  id          String   @id @default(cuid())
  userId      String
  name        String
  color       String   @default("#3B82F6")
  icon        String   @default("folder")
  parentId    String?
  
  createdAt   DateTime @default(now())
  
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent      LibraryFolder? @relation("SubFolders", fields: [parentId], references: [id])
  subFolders  LibraryFolder[] @relation("SubFolders")
  items       LibraryItem[]

  @@unique([userId, name, parentId])
  @@index([userId])
}

// ============== RESEARCH ALERTS ==============

model ResearchAlert {
  id              String   @id @default(cuid())
  userId          String
  projectId       String?
  
  name            String
  description     String?
  alertType       AlertType
  
  searchQuery     String?
  keywords        String[] @default([])
  authors         String[] @default([])
  journals        String[] @default([])
  
  frequency       AlertFrequency @default(DAILY)
  isActive        Boolean  @default(true)
  
  emailEnabled    Boolean  @default(true)
  inAppEnabled    Boolean  @default(true)
  
  lastTriggeredAt DateTime?
  nextCheckAt     DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project         Project? @relation(fields: [projectId], references: [id])
  discoveries     AlertDiscovery[]

  @@index([userId])
  @@index([projectId])
}

enum AlertType {
  NEW_PUBLICATION
  CITATION_UPDATE
  AUTHOR_ACTIVITY
  KEYWORD_TREND
  CUSTOM_QUERY
}

enum AlertFrequency {
  REAL_TIME
  HOURLY
  DAILY
  WEEKLY
}

model AlertDiscovery {
  id              String   @id @default(cuid())
  alertId         String
  workId          String?
  
  title           String
  metadata        Json     @default("{}")
  
  isRead          Boolean  @default(false)
  isActioned      Boolean  @default(false)
  
  discoveredAt    DateTime @default(now())
  
  alert           ResearchAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)

  @@index([alertId])
}

// ============== RESEARCH GRAPHS ==============

model ResearchGraph {
  id              String   @id @default(cuid())
  projectId       String?
  userId          String
  
  title           String
  description     String?
  graphType       GraphType @default(CITATION_NETWORK)
  
  nodes           Json     @default("[]")
  edges           Json     @default("[]")
  layoutData      Json?
  
  settings        Json     @default("{}")
  filters         Json     @default("{}")
  
  isPublic        Boolean  @default(false)
  shareToken      String?  @unique
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project         Project? @relation(fields: [projectId], references: [id])
  graphNodes      GraphNode[]

  @@index([userId])
  @@index([projectId])
}

enum GraphType {
  CITATION_NETWORK
  AUTHOR_COLLABORATION
  CONCEPT_CLUSTER
  TEMPORAL_EVOLUTION
}

model GraphNode {
  id              String   @id @default(cuid())
  graphId         String
  workId          String?
  
  nodeType        String   // paper, author, concept
  label           String
  metadata        Json     @default("{}")
  position        Json?    // {x, y}
  
  graph           ResearchGraph @relation(fields: [graphId], references: [id], onDelete: Cascade)
  work            Work?    @relation(fields: [workId], references: [id])

  @@index([graphId])
}

// ============== WRITING ASSISTANT ==============

model WritingProject {
  id              String   @id @default(cuid())
  userId          String
  projectId       String?
  
  title           String
  type            WritingType
  content         Json     @default("{}")  // TipTap JSON content
  
  citationStyle   String   @default("APA")
  targetLength    Int?
  
  status          WritingStatus @default(DRAFT)
  wordCount       Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project         Project? @relation(fields: [projectId], references: [id])
  sources         WritingSource[]

  @@index([userId])
  @@index([projectId])
}

enum WritingType {
  LITERATURE_REVIEW
  BACKGROUND
  METHODS
  RESULTS
  DISCUSSION
  ABSTRACT
}

enum WritingStatus {
  DRAFT
  IN_PROGRESS
  REVIEW
  COMPLETE
}

model WritingSource {
  id              String   @id @default(cuid())
  writingProjectId String
  workId          String
  
  citationKey     String?  // e.g., "Smith2024"
  notes           String?  @db.Text
  usedInSections  String[] @default([])
  
  createdAt       DateTime @default(now())
  
  writingProject  WritingProject @relation(fields: [writingProjectId], references: [id], onDelete: Cascade)
  work            Work     @relation(fields: [workId], references: [id])

  @@unique([writingProjectId, workId])
  @@index([writingProjectId])
}

// ============== API & WEBHOOKS ==============

model ApiKey {
  id              String   @id @default(cuid())
  organizationId  String
  
  name            String
  keyHash         String   @unique
  keyPrefix       String   // First 8 chars for display
  
  permissions     Json     @default("[]")
  rateLimit       Int      @default(1000)  // per hour
  
  lastUsedAt      DateTime?
  expiresAt       DateTime?
  isActive        Boolean  @default(true)
  
  createdAt       DateTime @default(now())
  
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  usageLogs       ApiKeyUsage[]

  @@index([organizationId])
  @@index([keyHash])
}

model ApiKeyUsage {
  id              String   @id @default(cuid())
  apiKeyId        String
  
  endpoint        String
  method          String
  statusCode      Int
  responseTime    Int      // ms
  
  createdAt       DateTime @default(now())
  
  apiKey          ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([apiKeyId, createdAt])
}

model Webhook {
  id              String   @id @default(cuid())
  organizationId  String
  
  url             String
  secret          String
  events          String[] @default([])
  
  isActive        Boolean  @default(true)
  failureCount    Int      @default(0)
  lastTriggeredAt DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  deliveries      WebhookDelivery[]

  @@index([organizationId])
}

model WebhookDelivery {
  id              String   @id @default(cuid())
  webhookId       String
  
  eventType       String
  payload         Json
  
  statusCode      Int?
  responseBody    String?  @db.Text
  responseTime    Int?     // ms
  
  status          WebhookDeliveryStatus @default(PENDING)
  attempts        Int      @default(1)
  lastAttemptAt   DateTime @default(now())
  
  createdAt       DateTime @default(now())
  
  webhook         Webhook  @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId])
}

enum WebhookDeliveryStatus {
  PENDING
  SUCCESS
  FAILED
  RETRYING
}

// ============== ACTIVITY & AUDIT ==============

model Activity {
  id              String   @id @default(cuid())
  userId          String
  projectId       String?
  
  type            ActivityType
  description     String
  metadata        Json     @default("{}")
  
  createdAt       DateTime @default(now())
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project         Project? @relation(fields: [projectId], references: [id])

  @@index([userId])
  @@index([projectId])
  @@index([createdAt])
}

enum ActivityType {
  PROJECT_CREATED
  PROJECT_UPDATED
  STUDY_IMPORTED
  SCREENING_DECISION
  PHASE_ADVANCED
  CONFLICT_RESOLVED
  EXTRACTION_COMPLETED
  QUALITY_ASSESSED
  EXPORT_GENERATED
  TEAM_MEMBER_ADDED
  TEAM_MEMBER_REMOVED
  TEAM_MEMBER_INVITED
  SETTINGS_UPDATED
}

model AuditLog {
  id              String   @id @default(cuid())
  organizationId  String
  userId          String?
  
  action          String
  resource        String
  resourceId      String?
  
  oldValue        Json?
  newValue        Json?
  
  ipAddress       String?
  userAgent       String?
  
  createdAt       DateTime @default(now())
  
  organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([userId])
  @@index([createdAt])
}

// ============== NOTIFICATIONS ==============

model Notification {
  id              String   @id @default(cuid())
  userId          String
  
  type            NotificationType
  title           String
  message         String   @db.Text
  metadata        Json     @default("{}")
  
  isRead          Boolean  @default(false)
  readAt          DateTime?
  
  createdAt       DateTime @default(now())
  
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([createdAt])
}

enum NotificationType {
  CONFLICT_DETECTED
  CONFLICT_RESOLVED
  IMPORT_COMPLETED
  EXPORT_READY
  TEAM_INVITATION
  MENTION
  DEADLINE_APPROACHING
  ALERT_DISCOVERY
  SYSTEM
}

// ============== PROJECT CHAT ==============

model ChatMessage {
  id          String   @id @default(cuid())
  projectId   String
  userId      String
  
  content     String   @db.Text
  replyToId   String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo     ChatMessage? @relation("ChatReplies", fields: [replyToId], references: [id])
  replies     ChatMessage[] @relation("ChatReplies")

  @@index([projectId, createdAt])
  @@index([userId])
}

// ============== BACKGROUND JOBS ==============

model Job {
  id              String   @id @default(cuid())
  type            String
  payload         Json
  
  status          JobStatus @default(PENDING)
  attempts        Int      @default(0)
  maxAttempts     Int      @default(3)
  
  result          Json?
  error           String?  @db.Text
  
  scheduledAt     DateTime?
  startedAt       DateTime?
  completedAt     DateTime?
  createdAt       DateTime @default(now())

  @@index([status])
  @@index([type])
  @@index([scheduledAt])
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}
